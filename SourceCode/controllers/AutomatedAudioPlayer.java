/* This class is the subclass of StreamingPlayer, play and record music events dervied from harmonic table 
 * The class provides a player that can be given new MusicStrings at runtime.
 * This class add new bits of a MusicString with the add() method.
 * The newly-added patterns are played immediately.
 * @author: Vu San Ha Huynh
 * References: JFugue library
 */
package controllers;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.locks.ReentrantLock;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.jfugue.Pattern;

public class AutomatedAudioPlayer extends StreamingPlayer {

    public int harmonicTableTime = 0;
    public int clock = 0;
    private final ReentrantLock lock = new ReentrantLock();

    public void incrementTime(int tempo) {
        harmonicTableTime += tempo;
    }

    public void incrementClock() {
        clock++;
    }
    
    public void resetClock() {
        clock = 0;
    }

    @Override
    public void resetTime() {
        harmonicTableTime = 0;
    }

    public Map<Integer, String> getRecordedHarmonicTablePattern() {
        return this.recordedHarmonicTablePattern;
    }

    public void playHarmonicTable(int note) {
        note += pitch;
        String fragment = instrument + volume + "[" + note + "]" + duration;
        parser.parse(new Pattern(fragment));

        /* record string pattern for convert to midi output
         * The pattern generated by arranged played note
         */
        if (isRecording) {
            synchronized (this) {
                System.out.println(clock);
                lock.lock();
                try {
                    if (recordedHarmonicTablePattern.containsKey(clock)) {
                        /* save a chord */
                        recordedHarmonicTablePattern.put(clock, recordedHarmonicTablePattern.get(clock) + "+[" + note + "]/" + (float) harmonicTableTime / 1000 + " ");
                    } else {
                        /* save seperated note */
                        System.out.println(instrument + volume + "[" + note + "]/" + (float) harmonicTableTime / 1000 + " ");
                        recordedHarmonicTablePattern.put(clock, instrument + volume + "[" + note + "]/" + (float) harmonicTableTime / 1000 + " ");
                        System.out.println(recordedHarmonicTablePattern.values());
                    }
                    resetTime();
                } finally {
                    lock.unlock();
                }
            }
        }
    }
}